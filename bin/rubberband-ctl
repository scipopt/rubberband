#!/usr/bin/env python

import click
from elasticsearch import Elasticsearch
from elasticsearch.dsl import Q, Search, Index
from elasticsearch.dsl.connections import connections
import glob
import logging
import os.path
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta

from rubberband.models import Result, File, TestSet, Settings
from rubberband.constants import FILE_INDEX, RESULT_INDEX, TESTSET_INDEX, SETTINGS_INDEX
from rubberband.utils import Importer
from rubberband.boilerplate import make_app

CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])
APP_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
PACKAGE_ROOT = os.path.join(APP_ROOT, "rubberband")

make_app(PACKAGE_ROOT)

es_logger = logging.getLogger('elasticsearch')
es_logger.setLevel(logging.INFO)

@click.group(context_settings=CONTEXT_SETTINGS)
def main():
    pass


@main.command()
def delete_indices():
    '''
    Delete all indices.
    '''
    logging.info('Deleting all indices')
    conn = connections.get_connection()
    conn.indices.delete(index=FILE_INDEX)
    conn.indices.delete(index=RESULT_INDEX)
    conn.indices.delete(index=TESTSET_INDEX)
    conn.indices.delete(index=SETTINGS_INDEX)


@main.command()
def create_indices():
    '''
    Create indices for the Result, File, TestSet objects.
    '''
    logging.info('Creating indices')
    TestSet.init()
    File.init()
    Result.init()
    Settings.init()
    settings_index = Index(SETTINGS_INDEX)
    result_index= Index(RESULT_INDEX)
    # Need to close the index before modifying the settings
    settings_index.close()
    result_index.close()
    settings_index.put_settings(body={"index.mapping.ignore_malformed": True})
    settings_index.put_settings(body={"index.mapping.total_fields.limit": 5000})
    result_index.put_settings(body={"index.mapping.total_fields.limit": 5000})
    settings_index.open()
    result_index.open()

@main.command()
def populate_indices():
    '''
    Seed Elasticsearch with results from the tests/data directory.
    '''
    logging.info('Populating indices')
    filepath = os.path.join(APP_ROOT, "tests", "data")
    out_files = glob.glob(os.path.join(filepath, "*.out"))
    set_files = glob.glob(os.path.join(filepath, "*.set"))
    err_files = glob.glob(os.path.join(filepath, "*.err"))
    meta_files = glob.glob(os.path.join(filepath, "*.meta"))
    solu_files = glob.glob(os.path.join(filepath, "*.solu"))

    count = 0
    for f in out_files:
        paths = [f]
        # remove the .out
        base = f[:-4]
        try:
            solu_file = os.path.join(APP_ROOT, "tests", "data", base.split(".")[1] + ".solu")
        except:
            solu_file = ""
        if base + ".set" in set_files:
            paths.append(base + ".set")
        if base + ".err" in err_files:
            paths.append(base + ".err")
        if base + ".meta" in meta_files:
            paths.append(base + ".meta")
        if solu_file in solu_files:
            paths.append(solu_file)
        c = Importer(user="debug")

        expdate = datetime.today()
        if count < 2:
            expdate = expdate + timedelta(days=2)
        elif 2 <= count and count < 5:
            expdate = expdate - timedelta(days=2)
        elif 5 <= count and count < 8:
            expdate = None
        c.process_files(paths, remove=False, expirationdate=expdate)
        count = count+1


@main.command()
def delete_expired_records():
    '''
    Delete TestSets whose expirationdate lies in the past.
    If a TestSet does have an expirationdate set, then it won't get deleted here.
    This should be run regularly (nightly, weekly)
    '''
    logging.info('Deleting expired records')
    t = TestSet.search()
    t = t.filter('range', **{'expirationdate':{'lte':'now'}})
    t = t.query("bool", filter=[
        Q("match", mode="debug"),
        Q("match", run_initiator="adm_timo")])
    for tr in t.scan():
        print("delete testset", tr.expirationdate, tr.mode, tr.index_timestamp, tr.run_initiator)
        tr.delete_all_associations()
        tr.delete()


if __name__ == "__main__":
    main()
